
#OLD PROJECTION

def proj(corrs_counts, corr_vec, corr_org, tiponorma,pauli_basis_4q):    

	variable_rho = cp.Variable((16,16), hermitian=True) #four qubit dm
	
	targ_mat=stato_from_corr(corr_vec,pauli_basis_4q) #for F
	#print(targ_mat)
	org_mat=stato_from_corr(corr_org,pauli_basis_4q) #for the constraints
	
	print(cp.installed_solvers())

	F=cp.norm(variable_rho-targ_mat, tiponorma)  
	
	# Set the remaining constraints
	constraints = [cp.trace(variable_rho) == 1, variable_rho >> 0] 
	
	# Construct the problem.
	objective = cp.Minimize(F)    
	
	###impose corr constarints
	for i in range(1,256): #not imposing normalization
		if corrs_counts[i-1]=="1":   
			corr_value=cp.real(cp.trace(pauli_basis_4q[i]@org_mat))
			constraints.append(cp.real(cp.trace(variable_rho@pauli_basis_4q[i])) == corr_value)   

	prob = cp.Problem(objective, constraints)
	result = [prob.solve(verbose=True,solver = 'SCS'), variable_rho.value]

	return result

# tentative new projection function that internally consideres density matrices
#I don't undesrstand why here the minimization is run against a random hermitian, instead of reducing the 
#difference between target and a-given matrix

def NewProj(nn_densityMatrix,target_densityMatrix, tiponorma):    

#for the constraints
	
	F=cp.norm(nn_densityMatrix-target_densityMatrix, tiponorma)  
	
	# Set the positivity. We can force the trace 1 in the network layer, positivity is wha we miss
	constraints = [ nn_densityMatrix >> 0] 
	
	# Construct the problem.
	objective = cp.Minimize(F)    
	
	###impose corr constraints. THIS IS NO LONGER NEEDED.
	#for i in range(1,256): #not imposing normalization
	#	if corrs_counts[i-1]=="1":   
	#		corr_value=cp.real(cp.trace(pauli_basis_4q[i]@org_mat))
	#		constraints.append(cp.real(cp.trace(variable_rho@pauli_basis_4q[i])) == corr_value)   

	prob = cp.Problem(objective)
	result_status = prob.solve(verbose=True, solver='SCS')
	optimized_matrix = nn_densityMatrix.value
	return result_status, optimized_matrix


